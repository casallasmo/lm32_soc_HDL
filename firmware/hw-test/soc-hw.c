#include "soc-hw.h"

uart_t  *uart0  = (uart_t *)   0x20000000;
timer_t *timer0 = (timer_t *)  0x30000000;
gpio_t  *gpio0  = (gpio_t *)   0x40000000;
//uart_t  *uart1  = (uart_t *)   0x20000000;
spi_t   *spi0   = (spi_t *)    0x50000000;
i2c_t   *i2c0   = (i2c_t *)    0x60000000;

isr_ptr_t isr_table[32];

// void prueba()
// {
// 	   uart0->rxtx=30;
// 	   timer0->tcr0 = 0xAA;
// 	   gpio0->ctrl=0x55;
// 	   spi0->rxtx=1;
// 	   spi0->nop1=2;
// 	   spi0->cs=3;
// 	   spi0->nop2=5;
// 	   spi0->divisor=4;
// 	   i2c0->rxtx=5;
// 	   i2c0->divisor=5;
//
// }
void tic_isr();
/***************************************************************************
 * IRQ handling
 */
void isr_null()
{
}

void irq_handler(uint32_t pending)
{
	int i;

	for(i=0; i<32; i++) {
		if (pending & 0x01) (*isr_table[i])();
		pending >>= 1;
	}
}

void isr_init()
{
	int i;
	for(i=0; i<32; i++)
		isr_table[i] = &isr_null;
}

void isr_register(int irq, isr_ptr_t isr)
{
	isr_table[irq] = isr;
}

void isr_unregister(int irq)
{
	isr_table[irq] = &isr_null;
}

/***************************************************************************
 * TIMER Functions
 */
void msleep(uint32_t msec)
{
	uint32_t tcr;

	// Use timer0.1
	timer0->compare1 = (FCPU/1000)*msec;
	timer0->counter1 = 0;
	timer0->tcr1 = TIMER_EN;

	do {
		//halt();
 		tcr = timer0->tcr1;
 	} while ( ! (tcr & TIMER_TRIG) );
}

void nsleep(uint32_t nsec)
{
	uint32_t tcr;

	// Use timer0.1
	timer0->compare1 = (FCPU/1000000)*nsec;
	timer0->counter1 = 0;
	timer0->tcr1 = TIMER_EN;

	do {
		//halt();
 		tcr = timer0->tcr1;
 	} while ( ! (tcr & TIMER_TRIG) );
}


uint32_t tic_msec;

void tic_isr()
{
	tic_msec++;
	timer0->tcr0     = TIMER_EN | TIMER_AR | TIMER_IRQEN;
}

void tic_init()
{
	tic_msec = 0;

	// Setup timer0.0
	timer0->compare0 = (FCPU/10000);
	timer0->counter0 = 0;
	timer0->tcr0     = TIMER_EN | TIMER_AR | TIMER_IRQEN;

	isr_register(1, &tic_isr);
}


/***************************************************************************
 * UART Functions
 */
void uart_init()
{
	//uart0->ier = 0x00;  // Interrupt Enable Register
	//uart0->lcr = 0x03;  // Line Control Register:    8N1
	//uart0->mcr = 0x00;  // Modem Control Register

	// Setup Divisor register (Fclk / Baud)
	//uart0->div = (FCPU/(57600*16));
}

char uart_getchar()
{
	while (! (uart0->ucr & UART_DR)) ;
	return uart0->rxtx;
}

void uart_putchar(char c)
{
	while (uart0->ucr & UART_BUSY) ;
	uart0->rxtx = c;
}

void uart_putstr(char *str)
{
	char *c = str;
	while(*c) {
		uart_putchar(*c);
		c++;
	}
}

/***************************************************************************
 * SPI Functions
 */
 // ASCII characters table
 unsigned char ASCII[] =
  {
	0x00, 0x00, 0x00, 0x00, 0x00 // 20 blankspace ' '
   ,0x00, 0x00, 0x5f, 0x00, 0x00 // 21 !
   ,0x00, 0x07, 0x00, 0x07, 0x00 // 22 "
   ,0x14, 0x7f, 0x14, 0x7f, 0x14 // 23 #
   ,0x24, 0x2a, 0x7f, 0x2a, 0x12 // 24 $
   ,0x23, 0x13, 0x08, 0x64, 0x62 // 25 %
   ,0x36, 0x49, 0x55, 0x22, 0x50 // 26 &
   ,0x00, 0x05, 0x03, 0x00, 0x00 // 27 '
   ,0x00, 0x1c, 0x22, 0x41, 0x00 // 28 (
   ,0x00, 0x41, 0x22, 0x1c, 0x00 // 29 )
   ,0x14, 0x08, 0x3e, 0x08, 0x14 // 2a *
   ,0x08, 0x08, 0x3e, 0x08, 0x08 // 2b +
   ,0x00, 0x50, 0x30, 0x00, 0x00 // 2c ,
   ,0x08, 0x08, 0x08, 0x08, 0x08 // 2d -
   ,0x00, 0x60, 0x60, 0x00, 0x00 // 2e .
   ,0x20, 0x10, 0x08, 0x04, 0x02 // 2f /
   ,0x3e, 0x51, 0x49, 0x45, 0x3e // 30 0
   ,0x00, 0x42, 0x7f, 0x40, 0x00 // 31 1
   ,0x42, 0x61, 0x51, 0x49, 0x46 // 32 2
   ,0x21, 0x41, 0x45, 0x4b, 0x31 // 33 3
   ,0x18, 0x14, 0x12, 0x7f, 0x10 // 34 4
   ,0x27, 0x45, 0x45, 0x45, 0x39 // 35 5
   ,0x3c, 0x4a, 0x49, 0x49, 0x30 // 36 6
   ,0x01, 0x71, 0x09, 0x05, 0x03 // 37 7
   ,0x36, 0x49, 0x49, 0x49, 0x36 // 38 8
   ,0x06, 0x49, 0x49, 0x29, 0x1e // 39 9
   ,0x00, 0x36, 0x36, 0x00, 0x00 // 3a :
   ,0x00, 0x56, 0x36, 0x00, 0x00 // 3b ;
   ,0x08, 0x14, 0x22, 0x41, 0x00 // 3c <
   ,0x14, 0x14, 0x14, 0x14, 0x14 // 3d =
   ,0x00, 0x41, 0x22, 0x14, 0x08 // 3e >
   ,0x02, 0x01, 0x51, 0x09, 0x06 // 3f ?
   ,0x32, 0x49, 0x79, 0x41, 0x3e // 40 @
   ,0x7e, 0x11, 0x11, 0x11, 0x7e // 41 A
   ,0x7f, 0x49, 0x49, 0x49, 0x36 // 42 B
   ,0x3e, 0x41, 0x41, 0x41, 0x22 // 43 C
   ,0x7f, 0x41, 0x41, 0x22, 0x1c // 44 D
   ,0x7f, 0x49, 0x49, 0x49, 0x41 // 45 E
   ,0x7f, 0x09, 0x09, 0x09, 0x01 // 46 F
   ,0x3e, 0x41, 0x49, 0x49, 0x7a // 47 G
   ,0x7f, 0x08, 0x08, 0x08, 0x7f // 48 H
   ,0x00, 0x41, 0x7f, 0x41, 0x00 // 49 I
   ,0x20, 0x40, 0x41, 0x3f, 0x01 // 4a J
   ,0x7f, 0x08, 0x14, 0x22, 0x41 // 4b K
   ,0x7f, 0x40, 0x40, 0x40, 0x40 // 4c L
   ,0x7f, 0x02, 0x0c, 0x02, 0x7f // 4d M
   ,0x7f, 0x04, 0x08, 0x10, 0x7f // 4e N
   ,0x3e, 0x41, 0x41, 0x41, 0x3e // 4f O
   ,0x7f, 0x09, 0x09, 0x09, 0x06 // 50 P
   ,0x3e, 0x41, 0x51, 0x21, 0x5e // 51 Q
   ,0x7f, 0x09, 0x19, 0x29, 0x46 // 52 R
   ,0x46, 0x49, 0x49, 0x49, 0x31 // 53 S
   ,0x01, 0x01, 0x7f, 0x01, 0x01 // 54 T
   ,0x3f, 0x40, 0x40, 0x40, 0x3f // 55 U
   ,0x1f, 0x20, 0x40, 0x20, 0x1f // 56 V
   ,0x3f, 0x40, 0x38, 0x40, 0x3f // 57 W
   ,0x63, 0x14, 0x08, 0x14, 0x63 // 58 X
   ,0x07, 0x08, 0x70, 0x08, 0x07 // 59 Y
   ,0x61, 0x51, 0x49, 0x45, 0x43 // 5a Z
   ,0x00, 0x7f, 0x41, 0x41, 0x00 // 5b [
   ,0x02, 0x04, 0x08, 0x10, 0x20 // 5c ¥
   ,0x00, 0x41, 0x41, 0x7f, 0x00 // 5d ]
   ,0x04, 0x02, 0x01, 0x02, 0x04 // 5e ^
   ,0x40, 0x40, 0x40, 0x40, 0x40 // 5f _
   ,0x00, 0x01, 0x02, 0x04, 0x00 // 60 `
   ,0x20, 0x54, 0x54, 0x54, 0x78 // 61 a
   ,0x7f, 0x48, 0x44, 0x44, 0x38 // 62 b
   ,0x38, 0x44, 0x44, 0x44, 0x20 // 63 c
   ,0x38, 0x44, 0x44, 0x48, 0x7f // 64 d
   ,0x38, 0x54, 0x54, 0x54, 0x18 // 65 e
   ,0x08, 0x7e, 0x09, 0x01, 0x02 // 66 f
   ,0x0c, 0x52, 0x52, 0x52, 0x3e // 67 g
   ,0x7f, 0x08, 0x04, 0x04, 0x78 // 68 h
   ,0x00, 0x44, 0x7d, 0x40, 0x00 // 69 i
   ,0x20, 0x40, 0x44, 0x3d, 0x00 // 6a j
   ,0x7f, 0x10, 0x28, 0x44, 0x00 // 6b k
   ,0x00, 0x41, 0x7f, 0x40, 0x00 // 6c l
   ,0x7c, 0x04, 0x18, 0x04, 0x78 // 6d m
   ,0x7c, 0x08, 0x04, 0x04, 0x78 // 6e n
   ,0x38, 0x44, 0x44, 0x44, 0x38 // 6f o
   ,0x7c, 0x14, 0x14, 0x14, 0x08 // 70 p
   ,0x08, 0x14, 0x14, 0x18, 0x7c // 71 q
   ,0x7c, 0x08, 0x04, 0x04, 0x08 // 72 r
   ,0x48, 0x54, 0x54, 0x54, 0x20 // 73 s
   ,0x04, 0x3f, 0x44, 0x40, 0x20 // 74 t
   ,0x3c, 0x40, 0x40, 0x20, 0x7c // 75 u
   ,0x1c, 0x20, 0x40, 0x20, 0x1c // 76 v
   ,0x3c, 0x40, 0x30, 0x40, 0x3c // 77 w
   ,0x44, 0x28, 0x10, 0x28, 0x44 // 78 x
   ,0x0c, 0x50, 0x50, 0x50, 0x3c // 79 y
   ,0x44, 0x64, 0x54, 0x4c, 0x44 // 7a z
   ,0x00, 0x08, 0x36, 0x41, 0x00 // 7b {
   ,0x00, 0x00, 0x7f, 0x00, 0x00 // 7c |
   ,0x00, 0x41, 0x36, 0x08, 0x00 // 7d }
   ,0x10, 0x08, 0x08, 0x10, 0x08 // 7e ←
   ,0x78, 0x46, 0x41, 0x46, 0x78 // 7f →
  };

// ok, it's working as it should
void spi_sendbyte(uint8_t c, uint8_t d_c)
{
	while (!(spi0->rst_done & SPI_RST_DONE) || (spi0->state)) ;
	// TODO cambiar a un solo registro
	spi0->spi_cs = 0;
	spi0->dc = d_c;
	spi0->rxtx = c;
}

void spi_lcd_putchar(char c, uint8_t r_size)
{
	uint8_t i;
	uint32_t k;
// para posicionarse en al arregle se toma el caracter, se le
// resta 32 que es ' ', despues se multiplica por m, que tiene el valor de 5, si se multiplica directamente por 5, no funciona el procesador o el compilador optimiza de alguna forma esa operacion y retorna un tipo de suma que no es util, sin embargo al darle el valor 5 a la variable y luego multiplicar por esa variable se obtiene el valor corrector, despues de eso se le suma i para que avance en el contenido del arreglo.
	k = (c-' ') * r_size;

	for (i = 0; i < 5; i++) {
		spi_sendbyte(*(ASCII+k+i), 1);
	}
	spi_sendbyte(0x00, 1);
   // uint32_t i;
   // char *p1;
   // p1 = c;
   // volatile uint32_t res1;
   // volatile uint32_t res2;
   // uint8_t k1;
   // uint8_t k2;
   // volatile uint8_t x = k;
   // volatile uint8_t y = 10;
   //
   // k1 = c - ' ';
   // res1 = k1 * 4;
   // spi_sendbyte(res1, 1);
   // k2 = c - ' ';
   // res2 = k2 * m;
   // spi_sendbyte(res2, 1);

}


void spi_lcd_putstring(char *str, uint8_t r_size)
{
 char *c = str;
  while (*c)
  {
    // usando spi_lcd_putchar se itera sobre un arreglo de char
	// y se envia cada caracter resultando entonces en el string apareciendo en el display lcd
	spi_lcd_putchar(*c, r_size);
	c++;
  }
}

// ok, it's working as it should
void spi_lcd_blank(void)
{
	int i;
  for ( i = 0; i < 504; i++)
  {
    spi_sendbyte(0x00, 1);
  }
}

// ok, it's working as it should
void spi_lcd_init(void)
{
	spi0->divisor = 0xFF;

	spi_sendbyte(EXTENDED_ISET,0);
	spi_sendbyte(BIAS_VAL,0);
	spi_sendbyte(CONTRAST_VAL,0);
	spi_sendbyte(BASIC_ISET,0);
	spi_sendbyte(NORMAL_MODE,0);
}
// ok, it's working as it should
void spi_lcd_invert()
{
	spi_sendbyte(INVERSE_MODE, 0);
}

uint8_t spi_lcd_getx()
{
	return spi0->x_pos;
}

uint8_t spi_lcd_gety()
{
	return spi0->y_pos;
}
//
// void spi_lcd_setx(uint8_t x)
// {
// 	spi_sendbyte(,0);
// }
//
// void spi_lcd_sety(uint8_t y)
// {
// 	spi_sendbyte(,0);
// }
